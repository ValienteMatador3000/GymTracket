<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Gym Tracker — Con Sesiones (v2.1.1)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- PWA manifest y meta -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#111111">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="icon" href="icon-192.png">

  <!-- Chart.js (UMD build) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <!-- =======================
       Estilos (inline, centralizados)
       =======================
       Comentarios:
       - Mantengo la estética minimalista en grises.
       - Muchas clases son reutilizadas en los templates dinámicos.
  -->
  <style>
    :root{
      --bg: #ffffff;
      --card: #fff;
      --muted: #777;
      --border: #e6e6e6;
      --accent: #111;
      --icon: #666;
      --shadow: 0 6px 18px rgba(0,0,0,0.06);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body {
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: var(--bg);
      color: var(--accent);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    header {
      padding:16px;
      text-align:center;
      border-bottom:1px solid var(--border);
      background:#fff;
    }
    header h1 { margin:0; font-size:18px; font-weight:600; }

    main { padding:12px; padding-bottom:88px; max-width:760px; margin:0 auto; }

    /* Sections */
    section { display:none; padding-top:10px; }
    section.active { display:block; }

    h2 { margin:8px 0 12px 0; font-size:16px; text-align:center; font-weight:600; }

    /* Cards */
    .card {
      background:var(--card);
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      margin:8px auto;
      max-width:720px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      box-shadow: var(--shadow);
      flex-direction: column;
    }
    .card .left { flex:1; text-align:left; }
    .card .left strong { display:block; font-size:15px; }
    .card .left .muted { color:var(--muted); font-size:13px; margin-top:6px; }

    /* Buttons / icons */
    .icon-btn {
      background:none;
      border:none;
      padding:8px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      color:var(--icon);
      border-radius:8px;
    }
    .icon-btn:hover { background:#f6f6f6; }
    .fab {
      position: fixed;
      right: 18px;
      bottom: 86px;
      width:54px; height:54px;
      border-radius:50%;
      border:none;
      background:var(--accent);
      color:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow:var(--shadow);
      cursor:pointer;
      font-size:22px;
    }

    /* Footer nav minimal */
    nav {
      position:fixed;
      left:0; right:0; bottom:0;
      display:flex;
      background:#fff;
      border-top:1px solid var(--border);
      z-index:100;
      height:64px;
      align-items:center;
      justify-content:space-around;
    }
    nav button {
      background:none; border:none; padding:8px 10px;
      display:flex; flex-direction:column; gap:2px; align-items:center; color:var(--icon); cursor:pointer;
      font-size:12px;
    }
    nav button.active { color:var(--accent); font-weight:600; }

    /* inputs */
    .input { padding:8px 10px; border-radius:8px; border:1px solid var(--border); background:#fff; width:100%; }
    label.muted { color:var(--muted); font-size:13px; display:block; margin-bottom:6px; }

    .row { display:flex; gap:8px; align-items:center; width:100%; }
    .btn { background:var(--accent); color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    .btn.secondary { background:#fff; color:var(--accent); border:1px solid var(--border); }
    .btn.small { padding:6px 10px; font-size:12px; }

    table { width:100%; border-collapse:collapse; margin-top:10px; }
    table th, table td { border:1px solid var(--border); padding:8px; text-align:center; font-size:13px; }
    table th { background:#fafafa; }

    .timer { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; font-size:28px; text-align:center; margin-top:8px; }

    /* modal */
    .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.32); display:flex; align-items:center; justify-content:center; z-index:200; }
    .modal { background:#fff; border-radius:12px; width:94%; max-width:560px; padding:14px; border:1px solid var(--border); box-shadow:var(--shadow); }
    .list { max-height:340px; overflow:auto; margin-top:8px; }
    .draggable { display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px; border-radius:8px; border:1px solid var(--border); margin-bottom:8px; background:#fff; }
    .handle { width:18px; height:18px; display:inline-block; background:linear-gradient(90deg,#ddd,#f6f6f6); border-radius:3px; margin-right:8px; }

    /* chart canvas */
    .chart-wrap { max-width:720px; margin:0 auto; border-radius:10px; overflow:hidden; background:#fff; border:1px solid var(--border); padding:12px; }
    /* Dar una altura mayor para mejorar visualización en móvil */
    .chart-wrap canvas { display:block; width:100%; height:360px; }

    /* small helpers */
    .muted { color:var(--muted); font-size:13px; }
    .small { font-size:13px; color:var(--muted); }
    .session-card { margin-bottom:16px; }
    .session-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
    .exercise-block { margin-top:12px; padding-top:12px; border-top:1px solid var(--border); }
    .series-item { display:flex; justify-content:space-between; padding:4px 0; font-size:13px; border-bottom:1px dashed var(--border); padding-bottom:8px; margin-bottom:8px; }

    /* accordion */
    .accordion{width:100%;border-radius:8px;overflow:hidden}
    .accordion-item{border:1px solid var(--border);border-radius:8px;margin-bottom:8px;background:#fff;}
    .accordion-header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;cursor:pointer;}
    .accordion-title{font-weight:600;}
    .accordion-body{padding:8px 12px;border-top:1px solid var(--border);display:none;max-height:0;overflow:hidden;transition:max-height .22s ease;}
    .accordion-body.open{display:block;max-height:1000px;}
    .badge{background:#f6f6f6;padding:4px 8px;border-radius:8px;font-size:12px;color:var(--muted);}
    .flex-between{display:flex;justify-content:space-between;align-items:center;}

    @media(min-width:720px){
      main { padding:20px; }
      .card { max-width:640px; }
    }
  </style>
</head>
<body>
  <!-- HEADER -->
  <header><h1>Gym Tracker</h1></header>

  <!-- MAIN: secciones EJERCICIOS / RUTINAS / ENTRENAMIENTO / PROGRESO -->
  <main>
    <!-- =========================
         SECCIÓN: EJERCICIOS
         ========================= -->
    <section id="ejercicios" aria-label="Mis ejercicios" class="active">
      <h2>Mis Ejercicios</h2>
      <div id="lista-ejercicios" aria-live="polite"></div>

      <!-- FAB para nuevo ejercicio -->
      <button class="fab" id="fab-nuevo-ejercicio" title="Nuevo ejercicio" aria-label="Nuevo ejercicio">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M12 5v14M5 12h14" stroke="white" stroke-width="2" stroke-linecap="round"/></svg>
      </button>
    </section>

    <!-- =========================
         SECCIÓN: RUTINAS
         ========================= -->
    <section id="rutinas" aria-label="Mis rutinas">
      <h2>Mis Rutinas</h2>
      <div id="lista-rutinas" aria-live="polite"></div>

      <!-- FAB para nueva rutina -->
      <button class="fab" id="fab-nueva-rutina" title="Nueva rutina" style="right:18px" aria-label="Nueva rutina">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M12 5v14M5 12h14" stroke="white" stroke-width="2" stroke-linecap="round"/></svg>
      </button>
    </section>

    <!-- =========================
         SECCIÓN: ENTRENAMIENTO
         ========================= -->
    <section id="entrenamiento" aria-label="Entrenamiento activo">
      <h2>Entrenamiento Activo</h2>

      <div class="card" style="align-items:stretch;">
        <div class="session-header" style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <label class="muted">Sesión actual</label>
            <div style="font-weight:600;" id="sesion-actual-info">Hoy</div>
          </div>
          <button class="btn small secondary" id="btn-nueva-sesion">Nueva Sesión</button>
        </div>

        <div style="margin-top:10px;">
          <label class="muted">Ejercicio actual</label>
          <select id="select-ejercicio" class="input" aria-label="Seleccionar ejercicio"></select>
        </div>

        <div class="row" style="margin-top:10px;">
          <div style="flex:1;">
            <label class="muted">Peso (kg)</label>
            <input id="peso" type="number" class="input" />
          </div>
          <div style="width:110px;">
            <label class="muted">Reps</label>
            <input id="reps" type="number" class="input" />
          </div>
          <div style="width:120px;display:flex;flex-direction:column;gap:8px;">
            <label class="muted">Descanso (seg)</label>
            <input id="input-temporizador-seg" class="input" type="number" min="5" step="5" />
          </div>
        </div>

        <div style="display:flex;gap:8px;margin-top:12px;justify-content:center;">
          <button class="btn" id="btn-guardar-serie">Añadir Serie</button>
          <button class="btn secondary" id="btn-iniciar-temporizador">Iniciar</button>
          <button class="btn secondary" id="btn-detener-temporizador">Detener</button>
        </div>

        <div style="margin-top:12px;">
          <div class="muted" style="margin-bottom:6px;">Series de hoy:</div>
          <div id="series-hoy"></div>
        </div>

        <div class="timer" id="temporizador">00:00</div>
      </div>
    </section>

    <!-- =========================
         SECCIÓN: PROGRESO
         ========================= -->
    <section id="progreso" aria-label="Progreso">
      <h2>Progreso</h2>

      <div style="max-width:720px;margin:0 auto;">
        <label class="muted">Selecciona ejercicio</label>
        <select id="select-progreso" class="input" style="margin-bottom:10px;"></select>

        <div class="chart-wrap">
          <canvas id="graficaProgreso"></canvas>
        </div>

        <div style="margin-top:20px;">
          <h3 style="font-size:14px; margin-bottom:8px;">Historial por Ejercicio</h3>
          <div id="historial-ejercicios"></div>
        </div>
      </div>
    </section>
  </main>

  <!-- NAV -->
  <nav aria-label="Navegación">
    <button id="nav-ejercicios" data-section="ejercicios" class="active" title="Ejercicios">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M4 6h16M4 12h16M4 18h16" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
      <span>Ejercicios</span>
    </button>
    <button id="nav-rutinas" data-section="rutinas" title="Rutinas">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><rect x="3" y="4" width="18" height="16" rx="2" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Rutinas</span>
    </button>
    <button id="nav-entrenamiento" data-section="entrenamiento" title="Entreno">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M12 2v20M5 7h14" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
      <span>Entreno</span>
    </button>
    <button id="nav-progreso" data-section="progreso" title="Progreso">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M3 17h4v-7H3v7zm6 0h4v-11h-4v11zm6 0h4v-4h-4v4z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>
      <span>Progreso</span>
    </button>
  </nav>

  <!-- CONTENEDOR DE MODALES (usado para insertar modales dinámicamente) -->
  <div id="modal-container" style="display:none;"></div>

<script>
/* ============================================================
   Gym Tracker v2.1.1 - index.html completo
   Comentarios técnicos en español (mantenimiento & explicación)
   ============================================================ */

/* ============================
   Sección: Datos y persistencia
   - Estructuras: ejercicios, rutinas, sesiones
   - LocalStorage como backend simple (sin sincronización remota)
   - Se implementa respaldo periódico automático
   ============================ */

let ejercicios = JSON.parse(localStorage.getItem('ejercicios')) || ["Sentadilla con Barra", "Press de Banca", "Peso Muerto"];
let rutinas = JSON.parse(localStorage.getItem('rutinas')) || [];
let sesiones = JSON.parse(localStorage.getItem('sesiones')) || [];
let temporizadorDefault = parseInt(localStorage.getItem('temporizadorDefault')) || 90;
let temporizadorState = JSON.parse(localStorage.getItem('temporizadorState')) || { running:false, restante: temporizadorDefault, lastTick:null };
let sesionActivaId = localStorage.getItem('sesionActivaId') || null;

/* Auto-respaldo: cada 5 minutos guardamos por seguridad */
const AUTOSAVE_INTERVAL_MS = 5 * 60 * 1000;
let autosaveTimer = null;

function saveAll(){
  // Guardado centralizado con protección para no bloquear el hilo
  try {
    localStorage.setItem('ejercicios', JSON.stringify(ejercicios));
    localStorage.setItem('rutinas', JSON.stringify(rutinas));
    localStorage.setItem('sesiones', JSON.stringify(sesiones));
    localStorage.setItem('temporizadorDefault', String(temporizadorDefault));
    localStorage.setItem('temporizadorState', JSON.stringify(temporizadorState));
    localStorage.setItem('sesionActivaId', sesionActivaId);
  } catch (e) {
    // LocalStorage puede fallar si el espacio es insuficiente; dejar registro para debugging.
    console.error('saveAll error', e);
  }
}

/* Inicia el temporizador de auto-guardado */
function startAutoSave(){
  if (autosaveTimer) clearInterval(autosaveTimer);
  autosaveTimer = setInterval(()=> {
    console.log('[autosave] guardando estado local...');
    saveAll();
  }, AUTOSAVE_INTERVAL_MS);
}

/* Detener autosave (por ejemplo en pruebas) */
function stopAutoSave(){
  if (autosaveTimer) clearInterval(autosaveTimer);
  autosaveTimer = null;
}

/* ============================
   Sección: Gestión de sesiones
   - crearNuevaSesion: crea y marca como activa
   - obtenerSesionActiva: retorna la sesión actual o crea nueva si no existe
   - actualizarInfoSesion: actualiza la UI correspondiente
   ============================ */

function crearNuevaSesion(){
  const hoy = new Date().toISOString().split('T')[0];
  const nuevaSesion = {
    id: 'sesion_' + Date.now(),
    fecha: hoy,
    nombre: `Entrenamiento ${hoy}`,
    ejercicios: {} // mapa: nombreEjercicio -> [ {peso,reps,fechaISO}, ... ]
  };
  sesiones.unshift(nuevaSesion);
  sesionActivaId = nuevaSesion.id;
  saveAll();
  return nuevaSesion;
}

function obtenerSesionActiva(){
  // Si no existe sesionActivaId, crear una nueva
  if (!sesionActivaId) {
    return crearNuevaSesion();
  }
  const sesion = sesiones.find(s => s.id === sesionActivaId);
  if (!sesion) {
    return crearNuevaSesion();
  }
  // Si la sesión activa no es de hoy, creamos nueva (evitar acumular días distintos en una misma sesión)
  const hoy = new Date().toISOString().split('T')[0];
  if (sesion.fecha !== hoy) {
    return crearNuevaSesion();
  }
  return sesion;
}

/* Actualiza texto de la UI que indica la sesión activa */
function actualizarInfoSesion(){
  const sesion = obtenerSesionActiva();
  const infoEl = document.getElementById('sesion-actual-info');
  if (infoEl && sesion) {
    infoEl.textContent = sesion.nombre;
  }
}

/* ============================
   Utilidades generales
   - escapeHtml: sanitiza texto para evitar inyección en innerHTML
   - fmtDateShort: formatea fecha YYYY-MM-DD a local
   - clamp: utilitario para limitar valores
   ============================ */

function escapeHtml(text){
  if (text === undefined || text === null) return '';
  return String(text).replace(/[&"'<>]/g, function (a) {
    return {'&':'&amp;','"':'&quot;',"'":"&#39;",'<':'&lt;','>':'&gt;'}[a];
  });
}
function fmtDateShort(dateStr){
  try {
    const d = new Date(dateStr + 'T00:00:00');
    return d.toLocaleDateString();
  } catch(e){ return dateStr; }
}
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

/* ============================
   Navegación entre secciones
   - showSection: oculta secciones y muestra la seleccionada
   - actualiza vista según sección
   ============================ */

function showSection(id){
  document.querySelectorAll('section').forEach(s => s.classList.remove('active'));
  const target = document.getElementById(id);
  if (target) target.classList.add('active');

  document.querySelectorAll('nav button').forEach(b=> b.classList.remove('active'));
  document.querySelectorAll('nav button').forEach(b=>{ if (b.dataset.section === id) b.classList.add('active'); });

  // acciones por sección
  if (id === 'ejercicios') renderEjercicios();
  if (id === 'rutinas') renderRutinas();
  if (id === 'entrenamiento') {
    renderEjercicios(); // refrescar listado de ejercicios
    actualizarInfoSesion();
    renderSeriesHoy();
    fillExerciseSelect();
  }
  if (id === 'progreso') {
    renderSelectProgreso();
    // drawChart() usa IntersectionObserver para evitar dibujar si está oculto; lo forzamos aquí
    setTimeout(()=> { drawChart(); renderHistorialByExercise(); }, 50);
  }
}

/* ============================
   Gestión de Ejercicios
   - renderEjercicios: dibuja la lista
   - openExerciseModal: modal para crear/editar ejercicio
   - eliminar ejercicio -> actualizar rutinas y sesiones
   ============================ */

function renderEjercicios(){
  const cont = document.getElementById('lista-ejercicios');
  cont.innerHTML = '';
  if (ejercicios.length === 0){
    const ph = document.createElement('div'); ph.className = 'card'; ph.innerHTML = '<div class="muted">No hay ejercicios. Pulsa + para crear uno.</div>';
    cont.appendChild(ph);
    return;
  }

  ejercicios.forEach((e,i)=>{
    const card = document.createElement('div'); card.className='card';
    const left = document.createElement('div'); left.className='left';
    left.innerHTML = `<strong>${escapeHtml(e)}</strong><div class="muted">Ejercicio #${i+1}</div>`;
    const actions = document.createElement('div'); actions.style.display='flex'; actions.style.gap='6px';
    const editBtn = document.createElement('button'); editBtn.className='icon-btn'; editBtn.title='Editar';
    editBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M3 21l3.9-.9L20.7 6.3a1 1 0 0 0 0-1.4L19.1 3.3a1 1 0 0 0-1.4 0L4.5 16.5 3 21z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
    editBtn.addEventListener('click', ()=> openExerciseModal(i));
    const delBtn = document.createElement('button'); delBtn.className='icon-btn'; delBtn.title='Borrar';
    delBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M3 6h18M8 6v14m8-14v14" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"/></svg>`;
    delBtn.addEventListener('click', ()=>{
      if (!confirm(`¿Eliminar ejercicio "${ejercicios[i]}"?`)) return;
      const removed = ejercicios.splice(i,1)[0];
      // Eliminamos referencia en rutinas
      rutinas = rutinas.map(r=> ({...r, ejercicios: r.ejercicios.filter(x=>x!==removed)}));
      // Eliminamos de sesiones
      sesiones.forEach(s => {
        if (s.ejercicios[removed]) {
          delete s.ejercicios[removed];
        }
      });
      saveAll();
      renderEjercicios(); renderRutinas(); renderSelectProgreso(); drawChart();
    });
    actions.appendChild(editBtn); actions.appendChild(delBtn);
    card.appendChild(left); card.appendChild(actions);
    cont.appendChild(card);
  });

  // después de renderizar, actualizar select del entrenamiento
  fillExerciseSelect();
}

/* Modal para crear/editar ejercicio (mejor que prompt: inputs editables) */
function openExerciseModal(index){
  const container = document.getElementById('modal-container'); container.innerHTML=''; container.style.display='block';
  const backdrop = document.createElement('div'); backdrop.className='modal-backdrop';
  const modal = document.createElement('div'); modal.className='modal';

  modal.innerHTML = `
    <header style="display:flex;justify-content:space-between;align-items:center;">
      <strong>${index==null ? 'Nuevo ejercicio' : 'Editar ejercicio'}</strong>
      <button id="close" class="icon-btn" title="Cerrar">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M6 18L18 6" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
      </button>
    </header>
    <div style="margin-top:10px;">
      <label class="muted">Nombre</label>
      <input id="nombre-ej" class="input" value="${index!=null ? escapeHtml(ejercicios[index]) : ''}" />
    </div>
    <div style="margin-top:12px;text-align:right;">
      <button id="cancel" class="btn secondary">Cancelar</button>
      <button id="save" class="btn">Guardar</button>
    </div>
  `;
  backdrop.appendChild(modal); container.appendChild(backdrop);

  modal.querySelector('#close').addEventListener('click', close);
  modal.querySelector('#cancel').addEventListener('click', close);
  modal.querySelector('#save').addEventListener('click', ()=>{
    const val = modal.querySelector('#nombre-ej').value && modal.querySelector('#nombre-ej').value.trim();
    if (!val){ alert('Escribe un nombre'); return; }
    if (index==null){
      ejercicios.push(val);
    } else {
      const old = ejercicios[index];
      ejercicios[index] = val;
      // actualizar rutinas que contenían el nombre antiguo
      rutinas = rutinas.map(r=> ({...r, ejercicios: r.ejercicios.map(x=> x===old ? val : x)}));
      // actualizar sesiones
      sesiones.forEach(s => {
        if (s.ejercicios[old]) {
          s.ejercicios[val] = s.ejercicios[old];
          delete s.ejercicios[old];
        }
      });
    }
    saveAll();
    close();
    renderEjercicios(); renderRutinas(); renderSelectProgreso(); drawChart();
  });

  function close(){ container.style.display='none'; container.innerHTML=''; }
}

/* ============================
   Sección: Rutinas
   - renderRutinas: lista con botones Iniciar/Editar/Borrar
   - openRutinaModal: modal con checkboxes y arrastrar para reordenar
   - iniciarRutina: cargará los ejercicios en el select de entrenamiento y cambia de sección
   ============================ */

function renderRutinas(){
  const cont = document.getElementById('lista-rutinas'); cont.innerHTML='';
  if (rutinas.length === 0){
    const ph = document.createElement('div'); ph.className='card'; ph.innerHTML = '<div class="muted">No hay rutinas. Pulsa + para crear una.</div>'; cont.appendChild(ph); return;
  }
  rutinas.forEach((r,i)=>{
    const card = document.createElement('div'); card.className='card';
    const left = document.createElement('div'); left.className='left';
    const lastUsed = findLastUsedDateForRoutine(r) || '';
    left.innerHTML = `<strong>${escapeHtml(r.nombre)}</strong><div class="muted">${r.ejercicios.length} ejercicios${lastUsed ? ' · Última: '+escapeHtml(lastUsed) : ''}</div>`;
    const actions = document.createElement('div'); actions.style.display='flex'; actions.style.gap='6px';
    const loadBtn = document.createElement('button'); loadBtn.className='btn'; loadBtn.title='Cargar rutina'; loadBtn.textContent='Iniciar';
    loadBtn.addEventListener('click', ()=> iniciarRutina(i));
    const editBtn = document.createElement('button'); editBtn.className='btn secondary'; editBtn.title='Editar'; editBtn.textContent='Editar';
    editBtn.addEventListener('click', ()=> openRutinaModal(i));
    const delBtn = document.createElement('button'); delBtn.className='btn secondary'; delBtn.title='Borrar'; delBtn.textContent='Borrar';
    delBtn.addEventListener('click', ()=> { if (!confirm(`¿Eliminar rutina "${r.nombre}"?`)) return; rutinas.splice(i,1); saveAll(); renderRutinas(); });

    actions.appendChild(loadBtn); actions.appendChild(editBtn); actions.appendChild(delBtn);
    card.appendChild(left); card.appendChild(actions); cont.appendChild(card);
  });
}

/* findLastUsedDateForRoutine: busca en sesiones la ultima vez que algun ejercicio de la rutina se uso */
function findLastUsedDateForRoutine(r){
  // recorre sesiones (más recientes primero), devuelve la fecha de la primera coincidencia
  for (const s of sesiones){
    for (const e of r.ejercicios){
      if (s.ejercicios && s.ejercicios[e] && s.ejercicios[e].length>0) return new Date(s.fecha).toLocaleDateString();
    }
  }
  return null;
}

/* Modal de Rutina: edición con reordenado y checkboxes
   - Se renderiza una lista combinada: los ejercicios de la rutina en primer lugar, luego los demás
   - Permite reordenar mediante drag & drop y botones subir/bajar
*/
function openRutinaModal(index){
  const container = document.getElementById('modal-container'); container.innerHTML=''; container.style.display='block';
  const backdrop = document.createElement('div'); backdrop.className='modal-backdrop';
  const modal = document.createElement('div'); modal.className='modal';
  const copy = index!=null ? JSON.parse(JSON.stringify(rutinas[index])) : {nombre:'', ejercicios:[]};
  modal.innerHTML = `
    <header style="display:flex;justify-content:space-between;align-items:center;">
      <strong>${index==null ? 'Nueva rutina' : 'Editar rutina'}</strong>
      <button id="close" class="icon-btn" title="Cerrar"><svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M6 18L18 6" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg></button>
    </header>
    <div style="margin-top:8px;">
      <label class="muted">Nombre</label>
      <input id="rutina-nombre" class="input" value="${escapeHtml(copy.nombre||'')}" />
    </div>
    <div style="margin-top:10px;">
      <strong class="small">Ejercicios (marca para incluir, arrastra para reordenar)</strong>
      <div class="list" id="rutina-list"></div>
    </div>
    <div style="margin-top:10px;text-align:right;">
      <button id="cancel" class="btn secondary">Cancelar</button>
      <button id="save" class="btn">Guardar</button>
    </div>
  `;
  backdrop.appendChild(modal); container.appendChild(backdrop);

  // Construimos 'order': primero los de la rutina, luego los demás no incluidos
  let order = [...(copy.ejercicios || [])];
  ejercicios.forEach(e => { if (!order.includes(e)) order.push(e); });

  function renderList(){
    const list = modal.querySelector('#rutina-list'); list.innerHTML='';
    order.forEach((name,idx)=>{
      const item = document.createElement('div'); item.className='draggable'; item.draggable=true; item.dataset.index = idx;
      const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center';
      left.innerHTML = `<span class="handle" aria-hidden></span><input type="checkbox" ${ (copy.ejercicios||[]).includes(name) ? 'checked' : '' } data-name="${escapeHtml(name)}" id="chk-${idx}" /><label for="chk-${idx}" style="margin-left:8px;">${escapeHtml(name)}</label>`;
      const right = document.createElement('div'); right.style.display='flex'; right.style.gap='6px';
      right.innerHTML = `<button class="icon-btn up" title="Subir">▲</button><button class="icon-btn down" title="Bajar">▼</button>`;
      item.appendChild(left); item.appendChild(right);
      list.appendChild(item);

      // Drag & drop simples
      item.addEventListener('dragstart', ev => { ev.dataTransfer.setData('text/plain', idx); item.style.opacity='0.5'; });
      item.addEventListener('dragend', ()=> item.style.opacity='1');
      item.addEventListener('dragover', ev => ev.preventDefault());
      item.addEventListener('drop', ev => {
        ev.preventDefault();
        const from = parseInt(ev.dataTransfer.getData('text/plain'),10);
        const to = parseInt(item.dataset.index,10);
        const moved = order.splice(from,1)[0];
        order.splice(to,0,moved);
        renderList();
      });

      right.querySelector('.up').addEventListener('click', ()=> {
        const i = idx; if (i<=0) return; [order[i-1],order[i]] = [order[i],order[i-1]]; renderList();
      });
      right.querySelector('.down').addEventListener('click', ()=> {
        const i = idx; if (i>=order.length-1) return; [order[i+1],order[i]] = [order[i],order[i+1]]; renderList();
      });

      left.querySelector('input[type=checkbox]').addEventListener('change', ev => {
        const n = name;
        if (ev.target.checked){
          if (!copy.ejercicios) copy.ejercicios = [];
          if (!copy.ejercicios.includes(n)) copy.ejercicios.push(n);
        } else {
          copy.ejercicios = (copy.ejercicios||[]).filter(x=>x!==n);
        }
      });
    });
  }
  renderList();

  modal.querySelector('#close').addEventListener('click', close);
  modal.querySelector('#cancel').addEventListener('click', close);
  modal.querySelector('#save').addEventListener('click', ()=>{
    const nombre = modal.querySelector('#rutina-nombre').value && modal.querySelector('#rutina-nombre').value.trim();
    if (!nombre){ alert('Pon un nombre a la rutina'); return; }
    const seleccion = order.filter(x => (copy.ejercicios||[]).includes(x));
    const nueva = { nombre, ejercicios: seleccion };
    if (index==null) rutinas.push(nueva); else rutinas[index] = nueva;
    saveAll();
    close();
    renderRutinas();
  });

  function close(){ container.style.display='none'; container.innerHTML=''; }
}

function nuevaRutina(){ if (ejercicios.length===0){ alert('Primero crea ejercicios.'); return; } openRutinaModal(null); }

/* iniciarRutina: copia los ejercicios seleccionados al select y cambia a sección entrenamiento
   - Si quieres podríamos además crear una sesión pre-llenada con esa rutina
*/
function iniciarRutina(i){
  const r = rutinas[i];
  if (!r || !r.ejercicios || r.ejercicios.length===0){ alert('La rutina no tiene ejercicios.'); return; }
  const select = document.getElementById('select-ejercicio'); select.innerHTML='';
  r.ejercicios.forEach(e => { const opt = document.createElement('option'); opt.value = e; opt.textContent = e; select.appendChild(opt); });
  showSection('entrenamiento');
}

/* ============================
   Entrenamiento: registrar series, editar, eliminar
   - fillExerciseSelect: rellena select con ejercicios disponibles (incluye rutinas)
   - guardarSerie: registro seguro en la sesión actual (evita duplicados cercanos)
   - renderSeriesHoy: muestra las series y botones editar/borrar
   - editarSerieSesion: abre modal de edición (en lugar de prompt)
   - eliminarSerieSesion: elimina con confirmación
   ============================ */

function fillExerciseSelect(){
  const select = document.getElementById('select-ejercicio');
  if (!select) return;
  const prev = select.value;
  select.innerHTML = '';
  const set = new Set(ejercicios);
  rutinas.forEach(r => (r.ejercicios||[]).forEach(e => set.add(e)));
  Array.from(set).forEach(e => { const opt = document.createElement('option'); opt.value = e; opt.textContent = e; select.appendChild(opt); });
  if (prev) select.value = prev;
}

/* Guardar serie en la sesión activa.
   - Validaciones básicas
   - Evita duplicados si se registró una serie igual en 10s previos
*/
function guardarSerie(){
  const select = document.getElementById('select-ejercicio');
  const ejercicio = select ? select.value : null;
  const pesoVal = document.getElementById('peso').value;
  const repsVal = document.getElementById('reps').value;
  if (!ejercicio){ alert('Selecciona un ejercicio.'); return; }
  if (!pesoVal || !repsVal){ alert('Introduce peso y repeticiones.'); return; }
  const peso = parseFloat(pesoVal);
  const reps = parseInt(repsVal,10);
  if (isNaN(peso) || isNaN(reps)){ alert('Valores inválidos'); return; }
  const fechaISO = new Date().toISOString();

  const sesion = obtenerSesionActiva();

  if (!sesion.ejercicios[ejercicio]) {
    sesion.ejercicios[ejercicio] = [];
  }

  const seriesEjercicio = sesion.ejercicios[ejercicio];
  if (seriesEjercicio.length > 0) {
    const last = seriesEjercicio[seriesEjercicio.length-1];
    if (last.peso === peso && last.reps === reps) {
      const diffSec = (new Date(fechaISO) - new Date(last.fechaISO)) / 1000;
      if (diffSec < 10){
        alert('Serie similar registrada hace pocos segundos. Evitado duplicado.');
        return;
      }
    }
  }

  const nuevaSerie = { peso, reps, fechaISO };
  seriesEjercicio.push(nuevaSerie);

  saveAll();
  renderSeriesHoy();

  const btn = document.getElementById('btn-guardar-serie'); btn.textContent = '✓ Añadido';
  setTimeout(()=> btn.textContent = 'Añadir Serie', 900);
}

/* renderSeriesHoy: muestra las series agrupadas por ejercicio con botones editar y borrar
   - Usamos modal para editar serie (mejor UX que prompt)
*/
function renderSeriesHoy(){
  const cont = document.getElementById('series-hoy');
  const sesion = obtenerSesionActiva();

  if (!sesion || Object.keys(sesion.ejercicios).length === 0) {
    cont.innerHTML = '<div class="muted">No hay series registradas hoy</div>';
    return;
  }

  let html = '';
  Object.entries(sesion.ejercicios).forEach(([ejercicio, series]) => {
    if (series.length > 0) {
      html += `<div class="exercise-block">`;
      html += `<div style="display:flex;justify-content:space-between;align-items:center;"><div style="font-weight:600; margin-bottom:4px;">${escapeHtml(ejercicio)}</div><div class="small">${series.length} series</div></div>`;
      series.forEach((serie, idx) => {
        html += `<div class="series-item">`;
        html += `<div style="display:flex;gap:12px;align-items:center;"><span>${serie.peso}kg</span><span class="muted">× ${serie.reps} reps</span></div>`;
        html += `<div style="display:flex;gap:8px;align-items:center;"><span class="muted">${new Date(serie.fechaISO).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>`;
        html += `<span><button class="btn small" data-ej="${escapeHtml(ejercicio)}" data-idx="${idx}" onclick="editarSerieSesionModal('${escapeHtml(ejercicio)}', ${idx})">Editar</button></span>`;
        html += `<span><button class="btn small secondary" data-ej="${escapeHtml(ejercicio)}" data-idx="${idx}" onclick="eliminarSerieSesion('${escapeHtml(ejercicio)}', ${idx})">Borrar</button></span></div>`;
        html += `</div>`;
      });
      html += `</div>`;
    }
  });

  cont.innerHTML = html;
}

/* editarSerieSesionModal: abre un modal con inputs para permitir edición completa
   - Permite borrar o limpiar campos sin problemas (a diferencia de prompt)
   - Validaciones y guardado
*/
function editarSerieSesionModal(ejercicio, index){
  const sesion = obtenerSesionActiva();
  if (!sesion || !sesion.ejercicios[ejercicio] || !sesion.ejercicios[ejercicio][index]) return;
  const s = sesion.ejercicios[ejercicio][index];

  // construir modal
  const container = document.getElementById('modal-container'); container.innerHTML=''; container.style.display='block';
  const backdrop = document.createElement('div'); backdrop.className='modal-backdrop';
  const modal = document.createElement('div'); modal.className='modal';
  modal.innerHTML = `
    <header style="display:flex;justify-content:space-between;align-items:center;">
      <strong>Editar serie — ${escapeHtml(ejercicio)}</strong>
      <button id="close" class="icon-btn" title="Cerrar">✕</button>
    </header>
    <div style="margin-top:10px;">
      <label class="muted">Peso (kg)</label>
      <input id="edit-peso" class="input" value="${s.peso}" />
    </div>
    <div style="margin-top:10px;">
      <label class="muted">Repeticiones</label>
      <input id="edit-reps" class="input" value="${s.reps}" />
    </div>
    <div style="margin-top:10px;">
      <label class="muted">Fecha/Hora</label>
      <input id="edit-fecha" class="input" value="${s.fechaISO}" />
      <div class="small muted">Formato ISO (puedes dejarlo)</div>
    </div>
    <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end;">
      <button id="delete" class="btn small secondary">Eliminar serie</button>
      <button id="cancel" class="btn small secondary">Cancelar</button>
      <button id="save" class="btn small">Guardar</button>
    </div>
  `;
  backdrop.appendChild(modal); container.appendChild(backdrop);

  // handlers
  modal.querySelector('#close').addEventListener('click', closeModal);
  modal.querySelector('#cancel').addEventListener('click', closeModal);

  modal.querySelector('#delete').addEventListener('click', ()=>{
    if (!confirm('¿Eliminar esta serie?')) return;
    sesion.ejercicios[ejercicio].splice(index,1);
    saveAll();
    closeModal();
    renderSeriesHoy();
    drawChart();
  });

  modal.querySelector('#save').addEventListener('click', ()=>{
    const pRaw = modal.querySelector('#edit-peso').value;
    const rRaw = modal.querySelector('#edit-reps').value;
    const fRaw = modal.querySelector('#edit-fecha').value;
    // validar
    const pesoNum = parseFloat(String(pRaw).trim());
    const repsNum = parseInt(String(rRaw).trim(),10);
    if (isNaN(pesoNum) || isNaN(repsNum)) { alert('Peso o repeticiones inválidas'); return; }
    // respetar formato ISO si es válido, si no, usar fecha anterior
    let fechaISO = s.fechaISO;
    try {
      const d = new Date(fRaw);
      if (!isNaN(d.getTime())) fechaISO = d.toISOString();
    } catch(e){}
    s.peso = pesoNum;
    s.reps = repsNum;
    s.fechaISO = fechaISO;
    saveAll();
    closeModal();
    renderSeriesHoy();
    drawChart();
  });

  function closeModal(){ container.style.display='none'; container.innerHTML=''; }
}

/* eliminarSerieSesion: confirm + eliminar + actualizar vistas */
function eliminarSerieSesion(ejercicio, index){
  const sesion = obtenerSesionActiva();
  if (!sesion || !sesion.ejercicios[ejercicio]) return;
  if (!confirm('¿Eliminar esta serie?')) return;
  sesion.ejercicios[ejercicio].splice(index,1);
  saveAll();
  renderSeriesHoy();
  drawChart();
}

/* nuevaSesion: crear sesión nueva con confirmación */
function nuevaSesion(){
  if (confirm('¿Crear nueva sesión de entrenamiento? Se perderá la sesión actual no guardada.')) {
    crearNuevaSesion();
    actualizarInfoSesion();
    renderSeriesHoy();
  }
}

/* ============================
   Temporizador preciso
   - Usa performance.now() y requestAnimationFrame para mayor precisión
   - Persistencia del estado para mantenerlo entre recargas
   - vibración y alerta al finalizar
   ============================ */

/* temporizadorRAF: id de requestAnimationFrame */
let temporizadorRAF = null;
let temporizadorStartPerf = null;
let temporizadorDuracionSeg = temporizadorDefault;

function actualizarTemporizadorUI(restante){
  const el = document.getElementById('temporizador');
  const mins = String(Math.floor(restante/60)).padStart(2,'0');
  const secs = String(restante%60).padStart(2,'0');
  el.textContent = `${mins}:${secs}`;
  const input = document.getElementById('input-temporizador-seg');
  if (input && !temporizadorState.running) input.value = temporizadorDefault;
}

function iniciarTemporizador(segundos=null){
  segundos = (segundos==null) ? parseInt(document.getElementById('input-temporizador-seg').value || temporizadorDefault,10) : segundos;
  if (!segundos || segundos <=0) segundos = temporizadorDefault;
  temporizadorDefault = segundos;
  temporizadorState.restante = segundos;
  temporizadorState.running = true;
  temporizadorStartPerf = performance.now();
  temporizadorState.lastTick = Date.now();
  saveAll();

  if (temporizadorRAF) cancelAnimationFrame(temporizadorRAF);
  function tick(now){
    const elapsed = (now - temporizadorStartPerf)/1000;
    const restante = Math.max(0, segundos - Math.floor(elapsed));
    actualizarTemporizadorUI(restante);
    temporizadorState.restante = restante;
    if (restante > 0){
      temporizadorRAF = requestAnimationFrame(tick);
    } else {
      temporizadorState.running = false;
      saveAll();
      temporizadorRAF = null;
      try { if (navigator.vibrate) navigator.vibrate([200,80,200]); } catch(e) {}
      alert('¡Descanso terminado!');
    }
  }
  temporizadorRAF = requestAnimationFrame(tick);
}

function detenerTemporizador(){
  temporizadorState.running = false;
  temporizadorState.lastTick = null;
  if (temporizadorRAF) cancelAnimationFrame(temporizadorRAF);
  temporizadorRAF = null;
  saveAll();
  actualizarTemporizadorUI(temporizadorDefault);
}

/* restoreTemporizadorOnLoad: ajusta el temporizador si estaba en curso */
function restoreTemporizadorOnLoad(){
  if (temporizadorState.running && temporizadorState.lastTick){
    const now = Date.now();
    const elapsed = Math.round((now - temporizadorState.lastTick)/1000);
    temporizadorState.restante = Math.max(0, (temporizadorState.restante||temporizadorDefault) - elapsed);
    if (temporizadorState.restante <= 0){
      temporizadorState.running = false;
      temporizadorState.restante = temporizadorDefault;
      temporizadorState.lastTick = null;
      saveAll();
      actualizarTemporizadorUI(temporizadorDefault);
    } else {
      iniciarTemporizador(temporizadorState.restante);
    }
  } else {
    temporizadorState.restante = temporizadorState.restante ?? temporizadorDefault;
    actualizarTemporizadorUI(temporizadorState.restante);
  }
}

/* ============================
   Graficas: Chart.js
   - Se implementa robustez: destruir instancia previa antes de crear una nueva
   - ensureCanvasSize: ajuste para devicePixelRatio para evitar gráficos borrosos o pequeños
   - aggregateByDay: agrupa series por día (peso máximo y volumen total por día)
   - IntersectionObserver para dibujar solo cuando la sección está visible
   - Redibujo en resize con debounce
   ============================ */

let chartInstance = null;

/* ensureCanvasSize: ajusta canvas.width/height teniendo en cuenta devicePixelRatio.
   - Debe ejecutarse antes de crear el Chart.js para evitar que el canvas aparezca pequeño
   - Utiliza clientWidth/clientHeight para calcular tamaño real
*/
function ensureCanvasSize(canvas) {
  if (!canvas) return;
  canvas.style.width = '100%';
  const computed = getComputedStyle(canvas);
  const cssHeight = parseFloat(computed.height) || canvas.clientHeight || 360;
  canvas.style.height = cssHeight + 'px';
  const ratio = window.devicePixelRatio || 1;
  const w = Math.round(canvas.clientWidth * ratio);
  const h = Math.round(canvas.clientHeight * ratio);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }
}

/* aggregateByDay: recibe un array de series con {peso,reps,fechaISO}
   - Retorna labels (dd/mm), pesos (max por día) y volumenes (suma por día)
*/
function aggregateByDay(series) {
  const grouped = {};
  series.forEach(s => {
    const d = new Date(s.fechaISO);
    const key = d.toISOString().split('T')[0]; // YYYY-MM-DD
    if (!grouped[key]) grouped[key] = { pesoMax: s.peso, volumen: s.peso * s.reps, items: [s] };
    else {
      grouped[key].pesoMax = Math.max(grouped[key].pesoMax, s.peso);
      grouped[key].volumen += s.peso * s.reps;
      grouped[key].items.push(s);
    }
  });
  const keys = Object.keys(grouped).sort((a,b) => new Date(a) - new Date(b));
  const labels = keys.map(k => {
    const d = new Date(k + 'T00:00:00');
    return `${d.getDate()}/${d.getMonth()+1}`;
  });
  const pesos = keys.map(k => grouped[k].pesoMax);
  const volumenes = keys.map(k => grouped[k].volumen);
  return { labels, pesos, volumenes, keys, grouped };
}

/* drawChart: crea o actualiza chartInstance.
   - Destruye instancia previa (si existe)
   - Ajusta tamaño del canvas antes de crear la instancia
   - Usa datasets: barras (volumen) + linea (peso)
*/
function drawChart(){
  const canvas = document.getElementById('graficaProgreso');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');

  // Obtener ejercicio seleccionado
  const select = document.getElementById('select-progreso');
  const ejercicio = select ? select.value : (ejercicios[0] || '');

  // Obtener series para ese ejercicio
  const todasLasSeries = obtenerTodasLasSeriesDeEjercicio(ejercicio);

  // Si no hay datos, limpiar canvas y mostrar placeholder
  ensureCanvasSize(canvas); // forzar tamaños independientemente
  if (!todasLasSeries.length){
    try {
      if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
    } catch(e){}
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#f8f8f8';
    ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    ctx.fillStyle = '#666'; ctx.font = '14px system-ui';
    ctx.textAlign='center'; ctx.fillText('No hay datos para este ejercicio', canvas.clientWidth/2, canvas.clientHeight/2);
    return;
  }

  // Agrupamos por día
  const { labels, pesos, volumenes } = aggregateByDay(todasLasSeries);

  // Destruimos instancia previa si existe para evitar error "Canvas already in use"
  if (chartInstance) {
    try { chartInstance.destroy(); } catch(e) { console.warn('Chart destroy error', e); }
    chartInstance = null;
  }

  // Calcular barThickness dinámico (para apariencia razonable)
  const barThickness = Math.max(10, Math.min(48, Math.floor((canvas.clientWidth / Math.max(1, labels.length)) * 0.6)));

  // Crear chart
  chartInstance = new Chart(ctx, {
    data: {
      labels,
      datasets: [
        {
          type: 'bar',
          label: 'Volumen',
          data: volumenes,
          backgroundColor: '#d0d0d0',
          yAxisID: 'y',
          barThickness
        },
        {
          type: 'line',
          label: 'Peso (kg)',
          data: pesos,
          borderColor: '#111',
          backgroundColor: '#111',
          pointRadius: 4,
          tension: 0.25,
          yAxisID: 'y2'
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: { padding: { top: 10, bottom: 6, left: 6, right: 6 } },
      plugins: {
        legend: { position: 'top', labels: { boxWidth: 12, color: '#111' } },
        tooltip: { mode: 'index', intersect: false }
      },
      interaction: { mode: 'index', intersect: false },
      scales: {
        x: { ticks: { color: '#666', maxRotation: 45, minRotation: 0 }, grid: { display: false } },
        y: { position: 'left', title: { display: true, text: 'Volumen', color: '#666' }, ticks: { color: '#666', beginAtZero: true } },
        y2: { position: 'right', grid: { drawOnChartArea: false }, title: { display: true, text: 'Peso (kg)', color: '#666' }, ticks: { color: '#666', beginAtZero: true } }
      },
      animation: { duration: 200 }
    }
  });

  // Forzamos un resize final (ayuda en algunos navegadores)
  try { chartInstance.resize(); } catch(e){}
}

/* obtenerTodasLasSeriesDeEjercicio: recorre sesiones y devuelve todas las series de un ejercicio */
function obtenerTodasLasSeriesDeEjercicio(ejercicio){
  const todasLasSeries = [];
  sesiones.forEach(sesion => {
    if (sesion.ejercicios[ejercicio]) {
      sesion.ejercicios[ejercicio].forEach(serie => {
        todasLasSeries.push({
          ...serie,
          sesionId: sesion.id,
          sesionFecha: sesion.fecha
        });
      });
    }
  });
  // ordenar por fecha ascendente
  return todasLasSeries.sort((a,b) => new Date(a.fechaISO) - new Date(b.fechaISO));
}

/* Debounce de resize para evitar redibujados masivos */
let chartResizeTimer = null;
window.addEventListener('resize', ()=> {
  if (chartResizeTimer) clearTimeout(chartResizeTimer);
  chartResizeTimer = setTimeout(()=> {
    // Si la sección "progreso" está activa, redibujamos
    if (document.getElementById('progreso').classList.contains('active')) drawChart();
    else if (chartInstance) { try { chartInstance.resize(); } catch(e){} }
  }, 120);
});

/* IntersectionObserver: detecta visibilidad de la sección progreso para dibujar solo cuando esté visible.
   - Mejora rendimiento y evita crear chart cuando canvas está oculto.
*/
(function setupProgresoObserver(){
  const progresoSection = document.getElementById('progreso');
  if (!('IntersectionObserver' in window) || !progresoSection) {
    // fallback: redibujar al focus o visibilitychange
    document.addEventListener('visibilitychange', ()=> {
      if (!document.hidden && document.getElementById('progreso').classList.contains('active')) drawChart();
    });
    return;
  }

  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        // cuando entra en vista
        drawChart();
      }
    });
  }, {root: null, threshold: 0.15});

  observer.observe(progresoSection);
})();

/* ============================
   Historial por ejercicio (Acordeón con carga diferida)
   - renderHistorialByExercise: crea headers y gestiona renderizado del cuerpo al abrir
   - Carga diferida: el contenido del body se genera solo cuando el usuario abre el acordeón
   ============================ */

function renderHistorialByExercise(){
  const container = document.getElementById('historial-ejercicios');
  container.innerHTML = '';

  // Generamos conjunto de ejercicios con historial: todos los ejercicios y los encontrados en sesiones
  const set = new Set();
  sesiones.forEach(s => { Object.keys(s.ejercicios||{}).forEach(e => set.add(e)); });
  ejercicios.forEach(e => set.add(e));
  const ejerciciosList = Array.from(set).sort();

  if (ejerciciosList.length === 0){
    container.innerHTML = '<div class="muted">Aún no hay historial de ejercicios</div>';
    return;
  }

  ejerciciosList.forEach(ej => {
    const item = document.createElement('div'); item.className = 'accordion-item';
    const header = document.createElement('div'); header.className = 'accordion-header';
    const title = document.createElement('div'); title.className = 'accordion-title'; title.textContent = ej;
    const summary = document.createElement('div'); summary.className='small';

    const allSeries = obtenerTodasLasSeriesDeEjercicio(ej);
    const mejorPeso = allSeries.length ? Math.max(...allSeries.map(s=>s.peso)) : 0;
    const totalSeries = allSeries.length;
    summary.innerHTML = `<span class="badge">Mejor: ${mejorPeso}kg</span> <span class="badge">Series: ${totalSeries}</span>`;

    const chevron = document.createElement('div'); chevron.innerHTML = '&#x25BC;'; chevron.style.color = 'var(--muted)';

    header.appendChild(title); header.appendChild(summary); header.appendChild(chevron);

    // Body vacío por defecto (render diferido)
    const body = document.createElement('div'); body.className = 'accordion-body'; body.dataset.loaded = 'false';

    // Handler: al hacer click abrimos/cierramos y si no está cargado lo renderizamos
    header.addEventListener('click', ()=>{
      const open = body.classList.contains('open');
      if (open){ body.classList.remove('open'); chevron.innerHTML='▼'; }
      else {
        body.classList.add('open'); chevron.innerHTML='▲';
        if (body.dataset.loaded === 'false') {
          // Renderizar contenido del body (solo una vez)
          renderHistoryBodyForExercise(ej, body);
          body.dataset.loaded = 'true';
        }
      }
    });

    item.appendChild(header); item.appendChild(body); container.appendChild(item);
  });
}

/* renderHistoryBodyForExercise: genera el contenido del acordeón para un ejercicio
   - Agrupa por sesión/fecha
   - Muestra lista de series con peso/reps/tiempo
   - Este render se hace solo cuando el acordeón se abre (carga diferida)
*/
function renderHistoryBodyForExercise(ej, bodyEl){
  bodyEl.innerHTML = ''; // limpiar
  const allSeries = obtenerTodasLasSeriesDeEjercicio(ej);
  if (allSeries.length === 0){
    bodyEl.innerHTML = '<div class="muted">No hay series registradas para este ejercicio</div>';
    return;
  }

  // Agrupar por sesionFecha
  const grouped = {};
  allSeries.forEach(s => {
    if (!grouped[s.sesionFecha]) grouped[s.sesionFecha] = [];
    grouped[s.sesionFecha].push(s);
  });

  // Ordenamos por fecha descendente (últimas primero)
  Object.keys(grouped).sort((a,b)=> new Date(b) - new Date(a)).forEach(sessionDate => {
    const sesDiv = document.createElement('div'); sesDiv.style.marginBottom = '8px';
    const header = document.createElement('div'); header.style.fontWeight = '600'; header.style.marginBottom = '6px';
    header.textContent = new Date(sessionDate).toLocaleDateString();
    sesDiv.appendChild(header);

    // Listado de series
    const list = document.createElement('div'); list.style.marginTop='6px';
    grouped[sessionDate].forEach(s => {
      const row = document.createElement('div'); row.className = 'series-item';
      const left = document.createElement('div'); left.innerHTML = `${s.peso}kg × ${s.reps} reps`;
      const right = document.createElement('div'); right.className='muted'; right.textContent = new Date(s.fechaISO).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});
      row.appendChild(left); row.appendChild(right);
      list.appendChild(row);
    });

    sesDiv.appendChild(list); bodyEl.appendChild(sesDiv);
  });
}

/* ============================
   Wiring / eventos iniciales (DOMContentLoaded)
   - Configuración de listeners globales
   - Restauración de estados: temporizador, selects, chart
   - Inicio de autosave
   ============================ */

document.addEventListener('DOMContentLoaded', ()=>{

  // NAV buttons
  document.querySelectorAll('nav button').forEach(b=>{
    b.addEventListener('click', ()=> showSection(b.dataset.section));
  });

  // FABs
  document.getElementById('fab-nuevo-ejercicio').addEventListener('click', ()=> openExerciseModal(null));
  document.getElementById('fab-nueva-rutina').addEventListener('click', ()=> openRutinaModal(null));

  // Entrenamiento listeners
  document.getElementById('btn-guardar-serie').addEventListener('click', guardarSerie);
  document.getElementById('btn-iniciar-temporizador').addEventListener('click', ()=> iniciarTemporizador());
  document.getElementById('btn-detener-temporizador').addEventListener('click', detenerTemporizador);
  document.getElementById('btn-nueva-sesion').addEventListener('click', nuevaSesion);

  // Input temporizador
  const inputTemp = document.getElementById('input-temporizador-seg');
  if (inputTemp) {
    inputTemp.value = temporizadorDefault;
    inputTemp.addEventListener('change', ()=>{
      const v = parseInt(inputTemp.value,10);
      if (isNaN(v) || v < 5) { inputTemp.value = temporizadorDefault; return; }
      temporizadorDefault = v;
      temporizadorState.restante = v;
      temporizadorState.running = false;
      saveAll();
      actualizarTemporizadorUI(v);
    });
  }

  // Select progreso: onchange redibuja chart y refresca historial
  const selProg = document.getElementById('select-progreso');
  if (selProg) selProg.addEventListener('change', ()=> { drawChart(); renderHistorialByExercise(); });

  // Redibujar chart en resize con debounce (ya declarado arriba)
  window.addEventListener('resize', ()=> {
    if (document.getElementById('progreso').classList.contains('active')) drawChart();
  });

  // Init views
  renderEjercicios();
  renderRutinas();
  renderSeriesHoy();
  renderSelectProgreso();
  restoreTemporizadorOnLoad();
  renderHistorialByExercise();

  // iniciar autosave
  startAutoSave();

  // Default section
  showSection('ejercicios');
});

/* renderSelectProgreso: llena select de progreso con ejercicios y rutinas
   - Intenta preservar la selección previa
*/
function renderSelectProgreso(){
  const sel = document.getElementById('select-progreso');
  if (!sel) return;
  const prev = sel.value;
  sel.innerHTML = '';
  const set = new Set(ejercicios);
  rutinas.forEach(r => (r.ejercicios||[]).forEach(e => set.add(e)));
  Array.from(set).forEach(e => {
    const opt = document.createElement('option'); opt.value = e; opt.textContent = e; sel.appendChild(opt);
  });
  if (prev) sel.value = prev;
  if (!sel.value && sel.options.length) sel.selectedIndex = 0;
  sel.onchange = ()=> { drawChart(); renderHistorialByExercise(); };
}

/* ============================
   Exponer funciones a window para debugging o uso en consola
   - Útil para desarrollo: window.drawChart(), window.openRutinaModal(), etc.
   ============================ */
window.drawChart = drawChart;
window.openRutinaModal = openRutinaModal;
window.openExerciseModal = openExerciseModal;

/* ============================
   Registro del Service Worker (PWA)
   - Se registra sólo si existe 'serviceWorker' en navigator
   - Dejarlo tal cual proporciona compatibilidad con tu sw.js ya existente
   ============================ */
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js')
    .then(reg => console.log('ServiceWorker registrado:', reg.scope))
    .catch(err => console.error('Error registrando ServiceWorker:', err));
}

/* ============================
   Fin del script
   - Archivo index.html listo para reemplazar
   - Comentarios y estructura preparados para mantenimiento
   ============================ */
</script>

</body>
</html>